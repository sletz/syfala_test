# `syfala_coreaudio`

A (work in progress) implementation of the protocol, for use with CoreAudio.

Uses the [`AudioServerPlugin`](https://developer.apple.com/documentation/coreaudio/creating-an-audio-server-driver-plug-in) API.

# Creating a CoreAudio HAL Plug-In

The AudioServerPlugin API is a specification for the format of CoreAudio HAL Plug-Ins. Extensions developers can write to extend CoreAudio with custom (even virtual) device drivers.

We will use the words "Driver" and "CoreAudio HAL Plug-In" interchangeably. But, note that the latter is the terminology most often used by Apple.

The Architecture of a CoreAudio HAL Plug-In is as follows:

```
<YOUR_DRIVER>.driver
└─ Contents/
    ├─ Info.plist
    ├─ MacOS/
    │   └─ <LIBRARY_NAME>
    └─ Resources/
        ├─ Files used by your driver
        └─ (localization, icons, strings, configs, etc.)
```

CoreAudio loads HAL Plug-Ins on launch. Which means that, to load a newly installed driver, you must either relaunch your system, or kill the CoreAudio Daemon process completely. It will be automatically relaunched by your system, at which point it will attempt to load your plugin.

## The `Info.plist` file

The `Info.plist` file in your driver's `Contents` directory, is an XML table that contains important metadata about your driver, as well as important information on what CoreAudio should do after loading it.

Here's a very minimal example of it's contents:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
        <string>$BUNDLE_ID</string>
    <key>CFBundleName</key>
        <string>$BUNDLE_NAME</string>
    <key>CFBundleExecutable</key>
        <string>$LIBRARY_NAME</string>
    <key>AudioServerPlugin_Network</key>
        <true/>
    <key>CFBundleSupportedPlatforms</key>
        <array>
            <string>MacOSX</string>
        </array>
    <key>CFBundleVersion</key>
        <string>$DRIVER_VERSION</string>
    <key>CFPlugInFactories</key>
        <dict>
            <key>$FACTORY_UUID</key>
                <string>$FACTORY_FUNCTION</string>
        </dict>
    <key>CFPlugInTypes</key>
        <dict>
            <key>443ABAB8-E7B3-491A-B985-BEB9187030DB</key>
                <array>
                    <string>$FACTORY_UUID</string>
                </array>
        </dict>
</dict>
</plist>
```

### `$BUNDLE_ID`
 
 `$BUNDLE_ID` is the unique identifier for your Plug-In _in reverse domain notation_ (i.e. com.<organisation_name>.<product_name>).

### `BUNDLE_NAME`

`$BUNDLE_NAME` is the human readable name you can give to your plugin, this need not be the top-level directory's name, and is used mainly by CoreAudio.

### `$LIBRARY_NAME`

`$LIBRARY_NAME` is the name of the shared object/dynamic library to be loaded. CoreAudio will look for a file named `$LIBRARY_NAME` in `Contents/MacOS/` and attempt to load that as a _C Dynamic Library_. It is very important that, regardless of the source language (C, C++, Rust, Zig...), the library is compiled to respect the _C ABI_ for your target architecture and operating system, in this case, Aarch64 on MacOS. It is possible to use x86, and universal binaries as well. It must also contain the appropriate factory functions.

### `AudioServerPlugin_Network`

This key is used to allow the driver to access network resources (useful if you're building an audio-over-IP driver)

### `CfPluginFactories`
 
The `CFPluginFactories` entry must contain a dictionnary mapping unique UUIDs, _generated by the developer of the Plug-In_, in string form, (see $FACTORY_UUID) to symbol names exported by your library. Those symbols are the _Plug-In factories_ of your library. They are CoreAudio's entry point to your driver, and must always be declared in this file. The symbols you declare in this section are the only symbols your library needs to expose and you may give them whichever name you wish. It is important to note that, when compiled, when compiled, public symbols of shared/dynamic libraries are often prefixed with an underscore (`_`). This means that the names declared here are not necessarily equal to the name of the corresponding functions defined in your source code. To check them you can run the following command:

```shell
otool -Iv lib_yourplugin.dylib
```

Example output:

```shell
exports:
0x00000028  _your_function_name
```
Notice the leading underscore.

### `CFPluginTypes`

The `CFPluginTypes` entry must contain a dictionary mapping _Plug-In type UUIDs_ to the UUID of their factory function, (as previously defined in the `CFPluginFactories` table). In our case, since we only care about making `AudioServerPlugin`s, the dictionnary contains only one key, `443ABAB8-E7B3-491A-B985-BEB9187030DB`, which is the _Plug-In type UUID_, as specified by Apple, of `AudioServerPlugin`s. Notice that the value of that key is an array. Indeed, if, for some reason, you wish to create multiple drivers, that are loaded in the same library, and that share the same state, you can simply create new factory functions in your library, generate UUIDs for them and add them to `CFPluginFactories`, then append their UUIDs to this array. The author has never found any use for this mechanism at the time of writing.

It is important to not that this structure must be strictly respected, or CoreAudio will sliently fail to load your Plug-In.

## The `Resources` folder

At the time of writing, CoreAudio loads your Plug-In in an individual, sandboxed process, with limites access to the filesystem: only system libraries and headers, and the `Contents/Resources/` folder of your driver. Here, you can put anything you wish to use; Icons, strings, configuration files, localization files, etc.

## Signing your driver bundle

In order to be able to load your Plug-In, it must be codesigned, with your own Apple Developer Team ID. For that, you need to create and Apple Developer account, and sign your bundle with it.

### Finding your developer ID

If you have Xcode installed on your Mac, sign in to your Apple Developer account and then run:

```shell
security find-identity -p codesigning -v
```

You will see:

```
1) <long string> "Apple Development: <your-email> (<APPLE_DEV_ID>)"
```

Keep note of `<APPLE_DEV_ID>` (a 10-character string) as we will be using it for signing:

### Signing your bundle

Once you have an Apple Developer ID, and once you have a valid driver bundle, as specified above, you must now sign your driver bundle:

```shell 
codesign --force --deep --options runtime --sign "<APPLE_DEV_ID>" "path/to/<YOUR_DRIVER>.driver"
```

## Installing your bundle

You can now install your driver by moving it to the following path (requires root permissions):

```
/Library/Audio/Plug-Ins/HAL/
```

```shell
# just to make sure
sudo rm -rf "/Library/Audio/Plug-Ins/HAL/<YOUR_DRIVER>.driver"
sudo mv "path/to/<YOUR_DRIVER>.driver" "/Libary/Audio/Plug-Ins/HAL"
```

At this point, you must now relaunch the CoreAudio Daemon to load your Plug-In:

```shell
sudo killall -9 coreaudiod
```

## Building the Plug-In (Rust)

### `Cargo.toml`

Your `Cargo.toml` file must contain at least the following:

```toml
[package]
name = "<YOUR_DRIVER_NAME>"
version = "0.1.0"
edition = "2024"

[lib]

crate-type = ["cdylib"] # <- important

[target.'cfg(target_os = "macos")'.dependencies]

coreaudio-sys = "0.2" # <- bindings to CoreAudio system headers
log = { version = "0.4", features = ["std"] }
oslog = { version = "0.2", features = ["logger"] } # <- allows using apple unified logging system
```

Then, run:

```
cargo build -r
```

Then, place the library, created in the following path:

```
target/release/lib_<YOUR_DRIVER_NAME>.dylib
```

in the appropriate `<YOUR_DRIVER>.driver/Contents/MacOS/` directory, then install it as explained above.

### Architecture of an `AudioServerPlugin`

This section is more thoroughly explained in the code ([`lib.rs`](src/lib.rs)). We give an overview here, more detailed documentation can be found in the CoreAudio Headers as well. Usually you can follow the references to symbols from [Apple's Sample driver](https://developer.apple.com/documentation/coreaudio/creating-an-audio-server-driver-plug-in).

Otherwise, they can be found in your machine at the following path:

```

```

#### Factory functions

After correctly declaring them in your `Info.plist` file, you must expose public symbols that will create your plugin:

```rust
#[unsafe(no_mangle)] // <-- important
pub unsafe extern "C" fn create(
    _allocator: CFAllocatorRef,
    requested_type_uuid: CFUUIDRef,
) -> *mut std::os::raw::c_void {
    
    // return plugin pointer
}
```

These functions must be public, and compiles with the C ABI (`extern "C"`)

#### Plug-In Virtual Table

A Plug-In is simply a struct filled with function pointers