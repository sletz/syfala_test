# `syfala_coreaudio`

A (work in progress) implementation of the protocol, for use with CoreAudio.

Uses the [`AudioServerPlugin`](https://developer.apple.com/documentation/coreaudio/creating-an-audio-server-driver-plug-in) API.

# Creating a CoreAudio HAL Plug-In

The AudioServerPlugin API is a specification for the format of CoreAudio HAL Plug-Ins. Extensions developers can write to extend CoreAudio with custom (even virtual) device drivers.

We will use the words "Driver" and "CoreAudio HAL Plug-In" interchangeably. But, note that the latter is the terminology most often used by Apple.

The Architecture of a CoreAudio HAL Plug-In is as follows:

```
<YOUR_DRIVER>.driver
└─ Contents/
    ├─ Info.plist
    ├─ MacOS/
    │   └─ <LIBRARY_NAME>
    └─ Resources/
        ├─ Files used by your driver
        └─ (localization, icons, strings, configs, etc.)
```

CoreAudio loads HAL Plug-Ins on launch. Which means that, to load a newly installed driver, you must either relaunch your system, or kill the CoreAudio Daemon process completely. It will be automatically relaunched by your system, at which point it will attempt to load your plugin.

## The `Info.plist` file

The `Info.plist` file in your driver's `Contents` directory, is an XML table that contains important metadata about your driver, as well as important information on what CoreAudio should do after loading it.

Here's a very minimal example of it's contents:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
        <string>$BUNDLE_ID</string>
    <key>CFBundleName</key>
        <string>$BUNDLE_NAME</string>
    <key>CFBundleExecutable</key>
        <string>$LIBRARY_NAME</string>
    <key>AudioServerPlugin_Network</key>
        <true/>
    <key>CFBundleSupportedPlatforms</key>
        <array>
            <string>MacOSX</string>
        </array>
    <key>CFPlugInFactories</key>
        <dict>
            <key>$FACTORY_UUID</key>
                <string>$FACTORY_FUNCTION</string>
        </dict>
    <key>CFPlugInTypes</key>
        <dict>
            <key>443ABAB8-E7B3-491A-B985-BEB9187030DB</key>
                <array>
                    <string>$FACTORY_UUID</string>
                </array>
        </dict>
</dict>
</plist>
```

### `$BUNDLE_ID`
 
 `$BUNDLE_ID` is the unique identifier for your Plug-In _in reverse domain notation_ (i.e. com.<organisation_name>.<product_name>).

### `BUNDLE_NAME`

`$BUNDLE_NAME` is the human readable name you can give to your plugin, this need not be the top-level directory's name, and is used mainly by CoreAudio.

### `$LIBRARY_NAME`

`$LIBRARY_NAME` is the name of the shared object/dynamic library to be loaded. CoreAudio will look for a file named `$LIBRARY_NAME` in `Contents/MacOS/` and attempt to load that as a _C Dynamic Library_. It is very important that, regardless of the source language (C, C++, Rust, Zig...), the library is compiled to respect the _C ABI_ for your target architecture and operating system, in this case, Aarch64 on MacOS. It is possible to use x86, and universal binaries as well. It must also contain the appropriate factory functions.

### `AudioServerPlugin_Network`

This key is used to allow the driver to access network resources (useful if you're building an audio-over-IP driver)

### `CfPluginFactories`
 
The `CFPluginFactories` entry must contain a dictionnary mapping unique UUIDs, _generated by the developer of the Plug-In_, in string form, (see $FACTORY_UUID) to symbol names exported by your library. Those symbols are the _Plug-In factories_ of your library. They are CoreAudio's entry point to your driver, and must always be declared in this file. The symbols you declare in this section are the only symbols your library needs to expose and you may give them whichever name you wish. It is important to note that, when compiled, when compiled, public symbols of shared/dynamic libraries are often prefixed with an underscore (`_`). This means that the names declared here are not necessarily equal to the name of the corresponding functions defined in your source code.

To check them you can run the following command:

```shell
otool -Iv lib_yourplugin.dylib
```

Example output:

```shell
exports:
0x00000028  _your_function_name
```
Notice the leading underscore.

### `CFPluginTypes`

The `CFPluginTypes` entry must contain a dictionary mapping _Plug-In type UUIDs_ to the UUID of their factory function, (as previously defined in the `CFPluginFactories` table). In our case, since we only care about making `AudioServerPlugin`s, the dictionnary contains only one key, `443ABAB8-E7B3-491A-B985-BEB9187030DB`, which is the _Plug-In type UUID_, as specified by Apple, of `AudioServerPlugin`s. Notice that the value of that key is an array. Indeed, if, for some reason, you wish to create multiple drivers, that are loaded in the same library, and that share the same state, you can simply create new factory functions in your library, generate UUIDs for them and add them to `CFPluginFactories`, then append their UUIDs to this array. The author has never found any use for this mechanism at the time of writing.

It is important to not that this structure must be strictly respected, or CoreAudio will sliently fail to load your Plug-In.

## The `Resources` folder

At the time of writing, CoreAudio loads your Plug-In in an individual, sandboxed process, with limites access to the filesystem: only system libraries and headers, and the `Contents/Resources/` folder of your driver. Here, you can put anything you wish to use; Icons, strings, configuration files, localization files, etc.

## Signing your driver bundle

In order to be able to load your Plug-In, it must be codesigned, with your own Apple Developer Team ID. For that, you need to create and Apple Developer account, and sign your bundle with it.

### Finding your developer ID

If you have Xcode installed on your Mac, sign in to your Apple Developer account and then run:

```shell
security find-identity -p codesigning -v
```

You will see:

```
1) <long string> "Apple Development: <your-email> (<APPLE_DEV_ID>)"
```

Keep note of `<APPLE_DEV_ID>` (a 10-character string) as we will be using it for signing:

### Signing your bundle

Once you have an Apple Developer ID, and once you have a valid driver bundle, as specified above, you must now sign your driver bundle:

```shell 
codesign --force --deep --options runtime --sign "<APPLE_DEV_ID>" "path/to/<YOUR_DRIVER>.driver"
```

## Installing your bundle

You can now install your driver by moving it to the following path (requires root permissions):

```
/Library/Audio/Plug-Ins/HAL/
```

```shell
# just to make sure
sudo rm -rf "/Library/Audio/Plug-Ins/HAL/<YOUR_DRIVER>.driver"
sudo mv "path/to/<YOUR_DRIVER>.driver" "/Libary/Audio/Plug-Ins/HAL"
```

At this point, you must now relaunch the CoreAudio Daemon to load your Plug-In:

```shell
sudo killall -9 coreaudiod
```

## Building the Plug-In (Rust)

### `Cargo.toml`

Your `Cargo.toml` file must contain at least the following:

```toml
[package]
name = "<YOUR_DRIVER_NAME>"
version = "0.1.0"
edition = "2024"

[lib]

crate-type = ["cdylib"] # <- important

[target.'cfg(target_os = "macos")'.dependencies]

coreaudio-sys = "0.2" # <- bindings to CoreAudio system headers
log = { version = "0.4", features = ["std"] }
oslog = { version = "0.2", features = ["logger"] } # <- allows using apple unified logging system
```

Then, run:

```
cargo build -r
```

Then, place the library, created in the following path:

```
target/release/lib_<YOUR_DRIVER_NAME>.dylib
```

in the appropriate `<YOUR_DRIVER>.driver/Contents/MacOS/` directory, then install it as explained above.

### Architecture of an `AudioServerPlugin`

This section is more thoroughly explained in the code ([`lib.rs`](src/lib.rs)). We give an overview here, more detailed documentation can be found in the CoreAudio Headers as well. Usually you can follow the references to symbols from [Apple's Sample driver](https://developer.apple.com/documentation/coreaudio/creating-an-audio-server-driver-plug-in).

Otherwise, they can be found in your machine at the following path:

```
/Library/Developer/CommandLineTools/SDKs/MacOSX<YOUR_MACOS_VERSION>.sdk/System/Library/Frameworks/CoreAudio.framework/Versions/A/Headers
```

Specifically, the `AudioServerPlugin.h`, and `AudioHardwareBase.h` headers

#### Factory functions

After correctly declaring them in your `Info.plist` file, you must expose public symbols that will create your plugin:

```rust
#[unsafe(no_mangle)] // <-- important
pub unsafe extern "C" fn create(
    _allocator: CFAllocatorRef,
    requested_type_uuid: CFUUIDRef,
) -> *mut std::os::raw::c_void {
    
    // return plugin pointer
}
```

These functions must be public, and compiles with the C ABI (`extern "C"`)

#### Plug-In Virtual Table

A Plug-In is simply a struct with function pointers, defining the behavior of the Plug-In. Any state management needs to be made through `static`s created within your library. Each must have respect a specific signature, and be compiled with the C ABI. (`extern "C"`).

See the `DRIVER_INTERFACE` static variable, as an example.

#### Initialization

One of the methods in this virtual table is your driver's initialisation routine. This routine is called only once at Plug-In launch and must:

 - Perform any one-time state initialization (Background network threads)
 - Store the host virtual pointer passed in it. This table contains methods the Plug-In may call at any time, in any thread, to notify the HAL of changes in its Objects/Properties.

#### Audio Object Model

Across all of CoreAudio, property information communication is done using an Object/Property model:

 - The plugin generates unique 32 bit IDs for it's objects.
 - The HAL queries them for their Class, Owner, Owned objects, and properties

Objects can be devices, streams, controls/parameters/sliders, or the Plug-In itself

There is an exception to this, the `kAudioPluginObject` (or 1) Object ID is reserved. And it represents the whole Plug-In. The HAL always starts by immediately querying this object after creating the Plug-In and initializing it. For example the HAL will ask the plugin object (ID = 1) for it's device list. A plugin that owns three devices will return three IDs, that it must generate and maintain, (e.g. 4, 597, and 6) the HAL will then query each of those Object IDs, for their own properties, sub-objects and, in turn, query those objects etc.

At any time, when any property changes, The Plug-In can use the Host pointer it has stored in the initialization function, to report to the HAL that a property has changed. For example, if new device has been detected, the Plug-In must report that the property `kAudioPluginPropertyDeviceList` of the Object whose ID is 1 (i.e. the plug-in object), has changed, at which point the HAL will call query it again, and create/destroy new devices...

#### Querying Objects/Properties

The `AudioServerPlugIn` vtable has 5 methods for interacting with objects and properties:

 - `HasProperty` Takes an Object ID and a property address and returns whether that property exists for that object.
 - `IsPropertySettable` Takes an Object ID and a property address and returns whether that property is settable for that object
 - `GetPropertyDataSize` Takes an Object ID and a property address and returns the size, in bytes, of the data associated with that property for the object
 - `GetPropertyData` Takes an Object ID and a property address and returns the data associated with the property for the selected object, the HAL presumably has allocated enough space for the data you will write, as reported by `GetPropertyData`.
 - `SetPropertyData` Takes an Object ID and a property address and sets the value of the property to the value passed in. This is usually where Audio MIDI Setup performs control changes when you change the value of sliders, volume, stream formats and sample rates etc...

Important: _ALL_ of the above functions must be thread safe, but not real-time safe. It is important to use atomics/locks for parameters in your internal plug-in state.

#### Audio IO