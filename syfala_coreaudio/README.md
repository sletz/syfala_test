# `syfala_coreaudio`

A (very incomplete) implementation of the protocol, for use with CoreAudio.

Uses the [`AudioServerPlugin`](https://developer.apple.com/documentation/coreaudio/creating-an-audio-server-driver-plug-in) API.

# Creating a CoreAudio HAL Plug-In

The AudioServerPlugin API is a specification for the format of CoreAudio HAL Plug-Ins. Extensions developers can write to extend CoreAudio with custom (even virtual) device drivers.

We will use the words "Driver" and "CoreAudio HAL Plug-In" interchangeably. But, note that the latter is the terminology most often used by Apple.

The Architecture of a CoreAudio HAL Plug-In is as follows:

```
<YOUR_DRIVER>.driver
└─ Contents/
    ├─ Info.plist
    ├─ MacOS/
    │   └─ <LIBRARY_NAME>
    └─ Resources/
        ├─ Files used by your driver
        └─ (localization, icons, strings, configs, etc.)
```

CoreAudio loads HAL Plug-Ins on launch. Which means that, to load a newly installed driver, you must either relaunch your system, or kill the CoreAudio Daemon process completely. It will be automatically relaunched by your system, at which point it will attempt to load your plugin.

## The `Info.plist` file

The `Info.plist` file in your driver's `Contents` directory, is an XML table that contains important metadata about your driver, as well as important information on what CoreAudio should do after loading it.

Here's a very minimal example of it's contents:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
        <string>$BUNDLE_ID</string>
    <key>CFBundleName</key>
        <string>$BUNDLE_NAME</string>
    <key>CFBundleExecutable</key>
        <string>$LIBRARY_NAME</string>
    <key>AudioServerPlugin_Network</key>
        <true/>
    <key>CFBundleSupportedPlatforms</key>
        <array>
            <string>MacOSX</string>
        </array>
    <key>CFPlugInFactories</key>
        <dict>
            <key>$FACTORY_UUID</key>
                <string>$FACTORY_FUNCTION</string>
        </dict>
    <key>CFPlugInTypes</key>
        <dict>
            <key>443ABAB8-E7B3-491A-B985-BEB9187030DB</key>
                <array>
                    <string>$FACTORY_UUID</string>
                </array>
        </dict>
</dict>
</plist>
```

### `$BUNDLE_ID`
 
 `$BUNDLE_ID` is the unique identifier for your Plug-In _in reverse domain notation_ (i.e. com.<organisation_name>.<product_name>).

### `BUNDLE_NAME`

`$BUNDLE_NAME` is the human readable name you can give to your plugin, this need not be the top-level directory's name, and is used mainly by CoreAudio.

### `$LIBRARY_NAME`

`$LIBRARY_NAME` is the name of the shared object/dynamic library to be loaded. CoreAudio will look for a file named `$LIBRARY_NAME` in `Contents/MacOS/` and attempt to load that as a _C Dynamic Library_. It is very important that, regardless of the source language (C, C++, Rust, Zig...), the library is compiled to respect the _C ABI_ for your target architecture and operating system, in this case, Aarch64 on MacOS. It is possible to use x86, and universal binaries as well. It must also contain the appropriate factory functions.

### `AudioServerPlugin_Network`

This key is used to allow the driver to access network resources (useful if you're building an audio-over-IP driver)

### `CfPluginFactories`
 
The `CFPluginFactories` entry must contain a dictionnary mapping unique UUIDs, _generated by the developer of the Plug-In_, in string form, (see $FACTORY_UUID) to symbol names exported by your library. Those symbols are the _Plug-In factories_ of your library. They are CoreAudio's entry point to your driver, and must always be declared in this file. The symbols you declare in this section are the only symbols your library needs to expose and you may give them whichever name you wish. It is important to note that, when compiled, when compiled, public symbols of shared/dynamic libraries are often prefixed with an underscore (`_`). This means that the names declared here are not necessarily equal to the name of the corresponding functions defined in your source code.

To check them you can run the following command:

```shell
otool -Iv lib_yourplugin.dylib
```

Example output:

```shell
exports:
0x00000028  _your_function_name
```
Notice the leading underscore.

### `CFPluginTypes`

The `CFPluginTypes` entry must contain a dictionary mapping _Plug-In type UUIDs_ to the UUID of their factory function, (as previously defined in the `CFPluginFactories` table). In our case, since we only care about making `AudioServerPlugin`s, the dictionnary contains only one key, `443ABAB8-E7B3-491A-B985-BEB9187030DB`, which is the _Plug-In type UUID_, as specified by Apple, of `AudioServerPlugin`s. Notice that the value of that key is an array. Indeed, if, for some reason, you wish to create multiple drivers, that are loaded in the same library, and that share the same state, you can simply create new factory functions in your library, generate UUIDs for them and add them to `CFPluginFactories`, then append their UUIDs to this array. The author has never found any use for this mechanism at the time of writing.

It is important to not that this structure must be strictly respected, or CoreAudio will sliently fail to load your Plug-In.

## The `Resources` folder

At the time of writing, CoreAudio loads your Plug-In in an individual, sandboxed process, with limites access to the filesystem: only system libraries and headers, and the `Contents/Resources/` folder of your driver. Here, you can put anything you wish to use; Icons, strings, configuration files, localization files, etc.

## Signing your driver bundle

In order to be able to load your Plug-In, it must be codesigned, with your own Apple Developer Team ID. For that, you need to create and Apple Developer account, and sign your bundle with it.

### Finding your developer ID

If you have Xcode installed on your Mac, sign in to your Apple Developer account and then run:

```shell
security find-identity -p codesigning -v
```

You will see:

```
1) <long string> "Apple Development: <your-email> (<APPLE_DEV_ID>)"
```

Keep note of `<APPLE_DEV_ID>` (a 10-character string) as we will be using it for signing:

### Signing your bundle

Once you have an Apple Developer ID, and once you have a valid driver bundle, as specified above, you must now sign your driver bundle:

```shell 
codesign --force --deep --options runtime --sign "<APPLE_DEV_ID>" "path/to/<YOUR_DRIVER>.driver"
```

## Installing your bundle

You can now install your driver by moving it to the following path (requires root permissions):

```
/Library/Audio/Plug-Ins/HAL/
```

```shell
# just to make sure
sudo rm -rf "/Library/Audio/Plug-Ins/HAL/<YOUR_DRIVER>.driver"
sudo mv "path/to/<YOUR_DRIVER>.driver" "/Libary/Audio/Plug-Ins/HAL"
```

At this point, you must now relaunch the CoreAudio Daemon to load your Plug-In:

```shell
sudo killall -9 coreaudiod
```

## Building the Plug-In (Rust)

### `Cargo.toml`

Your `Cargo.toml` file must contain at least the following:

```toml
[package]
name = "<YOUR_DRIVER_NAME>"
version = "0.1.0"
edition = "2024"

[lib]

crate-type = ["cdylib"] # <- important

[target.'cfg(target_os = "macos")'.dependencies]

coreaudio-sys = "0.2" # <- bindings to CoreAudio system headers
log = { version = "0.4", features = ["std"] }
oslog = { version = "0.2", features = ["logger"] } # <- allows using apple unified logging system
```

Then, run:

```
cargo build -r
```

Then, place the library, created in the following path:

```
target/release/lib_<YOUR_DRIVER_NAME>.dylib
```

in the appropriate `<YOUR_DRIVER>.driver/Contents/MacOS/` directory, then install it as explained above.

### Architecture of an `AudioServerPlugin`

This section is more thoroughly explained in the code ([`lib.rs`](src/lib.rs)). We give an overview here, more detailed documentation can be found in the CoreAudio Headers as well. Usually you can follow the references to symbols from [Apple's Sample driver](https://developer.apple.com/documentation/coreaudio/creating-an-audio-server-driver-plug-in).

Otherwise, they can be found in your machine at the following path:

```
/Library/Developer/CommandLineTools/SDKs/MacOSX<YOUR_MACOS_VERSION>.sdk/System/Library/Frameworks/CoreAudio.framework/Versions/A/Headers
```

Specifically, the `AudioServerPlugin.h`, and `AudioHardwareBase.h` headers

#### Factory functions

After correctly declaring them in your `Info.plist` file, you must expose public symbols that will create your plugin:

```rust
#[unsafe(no_mangle)] // <-- important
pub unsafe extern "C" fn create(
    _allocator: CFAllocatorRef,
    requested_type_uuid: CFUUIDRef,
) -> *mut std::os::raw::c_void {
    
    // return plugin pointer
}
```

These functions must be public, and compiles with the C ABI (`extern "C"`)

#### Plug-In Virtual Table

A Plug-In is simply a struct with function pointers, defining the behavior of the Plug-In. Any state management needs to be made through `static`s created within your library. Each must have respect a specific signature, and be compiled with the C ABI. (`extern "C"`).

See the `DRIVER_INTERFACE` static variable, as an example.

#### Initialization

One of the methods in this virtual table is your driver's initialisation routine. This routine is called only once at Plug-In launch and must:

 - Perform any one-time state initialization (Background network threads)
 - Store the host virtual pointer passed in it. This table contains methods the Plug-In may call at any time, in any thread, to notify the HAL of changes in its Objects/Properties.

#### Audio Object Model

Across all of CoreAudio, property information communication is done using an Object/Property model:

 - The plugin generates unique 32 bit IDs for it's objects.
 - The HAL queries them for their Class, Owner, Owned objects, and properties

Objects can be devices, streams, controls/parameters/sliders, or the Plug-In itself

There is an exception to this, the `kAudioPluginObject` (or 1) Object ID is reserved. And it represents the whole Plug-In. The HAL always starts by immediately querying this object after creating the Plug-In and initializing it. For example the HAL will ask the plugin object (ID = 1) for it's device list. A plugin that owns three devices will return three IDs, that it must generate and maintain, (e.g. 4, 597, and 6) the HAL will then query each of those Object IDs, for their own properties, sub-objects and, in turn, query those objects etc.

At any time, when any property changes, The Plug-In can use the Host pointer it has stored in the initialization function, to report to the HAL that a property has changed. For example, if new device has been detected, the Plug-In must report that the property `kAudioPluginPropertyDeviceList` of the Object whose ID is 1 (i.e. the plug-in object), has changed, at which point the HAL will call query it again, and create/destroy new devices...

#### Querying Objects/Properties

The `AudioServerPlugIn` vtable has 5 methods for interacting with objects and properties:

 - `HasProperty` Takes an Object ID and a property address and returns whether that property exists for that object.
 - `IsPropertySettable` Takes an Object ID and a property address and returns whether that property is settable for that object
 - `GetPropertyDataSize` Takes an Object ID and a property address and returns the size, in bytes, of the data associated with that property for the object
 - `GetPropertyData` Takes an Object ID and a property address and returns the data associated with the property for the selected object, the HAL presumably has allocated enough space for the data you will write, as reported by `GetPropertyData`.
 - `SetPropertyData` Takes an Object ID and a property address and sets the value of the property to the value passed in. This is usually where Audio MIDI Setup performs control changes when you change the value of sliders, volume, stream formats and sample rates etc...

Important: _ALL_ of the above functions must be thread safe, but not real-time safe. It is important to use atomics/locks for parameters in your internal plug-in state.

#### Client connection

There methods in the that are used by the HAL, that pass in a Client ID (32 bits). A Client (or App, like REAPER, Apple Music, etc.) Is a piece of software that uses the CoreAudio _Client_ API and can connect to devices to play audio etc.

When `AddDeviceClient` is called, a new client ID is passed in, as well as a Device ID, the Client ID, is generated by the HAL, and the Device ID is one of the device IDs generated and exposed to the HAL by the Plug-In. The Plug-In must store the Client ID, and associate subsequent ClientID parameters with that value as coming from that specific client.

When `RemoveDeviceClient` is called, a client ID, previously reported to your driver by the HAL, as well as one of your device IDs, is passed in to indicate that that client has disconnected from that device. The Plug-In must destroy any state associated with that client.

These methods allow you to perform actions on a client-per-client basis if needed. If not needed, you can safely ignore all of the Client ID parameters.

#### Audio IO

An audio IO cycle's lifecycle is represented by called to the following methods:

 - `StartIO`: This method is used to indicate that a previously connected client wishes to start IO. The plugin must keep track of the number of clients doing IO at the moment, and increment the counter when this method is called, if the value was 0. the Plug-In may take as long as it needs to perform any initialization, any clock synchronisation with the hardware, allocating buffers etc...
 - `GetZeroTimeStamp`: This method is used to get the previous "Zero Timestamp" of the device. CoreAudio Models device timing with a series of periodic timestamps, CoreAudio then compares those timestamps with those of it's system clock and adjusts IO callback scheduling accordingly. For example, a Plug-In has a device with a nominal sample rate of 96000hz, and a zero timestamp period of 20000 samples, (both of these are properties on device objects). This means that when IO starts, CoreAudio expects to receive a timestamp every 20000/96000 ~ 0.208 seconds, and this method must return the latest of those timestamps at the time it is called. This can be done by having a thread constantly wait for a hardware interrupt, or a specific network packet, and atomically advancing the current sample time of the device by 20000 every time. This means that the hardware must also consistently try to send those timestamps every 0.208 seconds. This mechanism is how you allow external hardware devices to impose their own timing, which might be subject to drift, relatively to your system's clock.
 - `WillDoIOOperation` This method returns what IO operations the device can perform. The device can choose to read individual client audio before CoreAudio mixes it, or instead, let CoreAudio mix all client outputs then only receive the full mix, before sending it to the hardware.
 - `BeginIOOperation` This function is called before every IO process callback.
 - `DoIOOperation` This function is called for every stream on the device, and where the driver performs IO operations. Typically you should copy data to/from a ring buffer to/from the buffer passed in this function.
 - `EndIOOperation` This function is called _after_ every IO process callback.
 - `StopIO` This function is called when a client stops performing audio IO with this device, the Plug-In should keep track of the number of clients connected to that device, and decrement the counter when this method is called. When it reaches 0, the Plug-In may consider IO inactive on this device and perform any cleanup routines. This method may take as long as it needs, and need not be real-time safe.


## Installing this Plug-In

First you must build the library:

```shell
cd syfala_coreaudio
cargo build -r
```

Before running the install script, which incorporates all of the instructions in the beginning of this guide. You mst first open it (`scripts/install.sh`) and replace TEAM_ID with your own Apple Developer Team ID (the 10-character string).

Then, run it, while passing the location of the library as an argument. Note that cargo puts all build artifacts and binaries in the `target` folder, which can be found at the root of this repository:

```
./scripts/install.sh ../target/release/libsyfala_coreaudio.dylib
```

Warning: This script requires administrator privileges, and will forcibly kill `coreaudiod` to reload your plugin